Attribute VB_Name = "GenerateDPPMSummary"
Option Explicit
' This module generates daily, weekly, And monthly summaries of DPPM data from the "dppm-database" sheet.
' It uses the output table generated by GenerateDPPMTable.bas as its source.

' --- Procedure Name Constants For Status Bar ---
Private Const PROC_GENERATE_SUMMARY As String = "GenerateDPPMSummary"
Private Const PROC_GENERATE_SUMMARY_BY_TYPE As String = "GenerateSummaryByType"
Private Const PROC_LOAD_SUMMARY_CONFIG As String = "LoadSummaryConfig"

' --- Module-level Variables For Config ---
Private m_sDailySummarySheetName As String, m_sDailySummaryTableName As String
Private m_sWeeklySummarySheetName As String, m_sWeeklySummaryTableName As String
Private m_sMonthlySummarySheetName As String, m_sMonthlySummaryTableName As String
Private m_Config As Object                       ' Module-level config dictionary

Private Sub GenerateSummaryByType(summaryType As String)
    Dim wsSource As Worksheet, wsTarget As Worksheet
    Dim tblSource As ListObject, tblTarget As ListObject
    Dim lastRow As Long, targetRow As Long
    Dim sourceDataArr As Variant
    Dim sourceColDateIdx As Long, sourceColOverallQtyIdx As Long, sourceColOverallRejectIdx As Long, sourceColInspectedQtyIdx As Long, sourceColInspectedRejectIdx As Long
    Dim summaryDict As Object
    Dim key As Variant
    Dim dateValue As Variant
    Dim overallQuantity As Double, overallRejects As Double, inspectedQuantity As Double, inspectedRejects As Double
    Dim overallDPPM As Double, inspectedDPPM As Double
    Dim tempArray As Variant
    Dim i As Long
    Dim outputArr() As Variant                   ' Array to hold data for bulk write
    Dim targetSheetName As String, targetTableName As String
    Dim procName As String: procName = PROC_GENERATE_SUMMARY_BY_TYPE & " (" & summaryType & ")"
    Dim weekNum As Variant
    Dim yearPart As String

    Utils.UpdateStatusBarMessage "Generating " & summaryType & " Summary...", True
    On Error GoTo ErrorHandler

    ' Get source sheet and table (dppm-database)
    Set wsSource = Utils.GetSheet(Config.DPPM_OUTPUT_SHEET_NAME)
    If wsSource Is Nothing Then
        Utils.LogMessage "[" & procName & "] Source sheet '" & Config.DPPM_OUTPUT_SHEET_NAME & "' not found!", True
        GoTo CleanUp
    End If
    Set tblSource = wsSource.ListObjects(Config.DPPM_OUTPUT_TABLE_NAME)
    If tblSource Is Nothing Then
        Utils.LogMessage "[" & procName & "] Source table '" & Config.DPPM_OUTPUT_TABLE_NAME & "' not found on sheet '" & Config.DPPM_OUTPUT_SHEET_NAME & "'!", True
        GoTo CleanUp
    End If

    ' Determine target sheet and table names based on summary type
    Select Case summaryType
    Case "Daily"
        targetSheetName = Config.CONFIG_KEY_DPPM_DAILY_SHEET_NAME
        targetTableName = Config.CONFIG_KEY_DPPM_DAILY_TABLE_NAME
    Case "Weekly"
        targetSheetName = Config.CONFIG_KEY_DPPM_WEEKLY_SHEET_NAME
        targetTableName = Config.CONFIG_KEY_DPPM_WEEKLY_TABLE_NAME
    Case "Monthly"
        targetSheetName = Config.CONFIG_KEY_DPPM_MONTHLY_SHEET_NAME
        targetTableName = Config.CONFIG_KEY_DPPM_MONTHLY_TABLE_NAME
    Case Else
        Utils.LogMessage "[" & procName & "] Invalid summary type: '" & summaryType & "'", True
        GoTo CleanUp
    End Select

    ' Check for Excel sheet name length limit
    If Len(targetSheetName) > 31 Then
        Utils.LogMessage "[" & procName & "] Target sheet name '" & targetSheetName & "' exceeds Excel's 31 character limit!", True
        GoTo CleanUp
    End If

    ' Get or create the target sheet
    Set wsTarget = GetOrCreateSheet(ThisWorkbook, targetSheetName)
    If wsTarget Is Nothing Then
        Utils.LogMessage "[" & procName & "] Could not get or create target sheet '" & targetSheetName & "'.", True
        GoTo CleanUp
    End If

    ' Initialize dictionary For aggregation
    Set summaryDict = CreateObject("Scripting.Dictionary")

    ' Read source data into an array
    If tblSource.ListRows.Count = 0 Then
        Utils.LogMessage "[" & procName & "] Source table '" & tblSource.Name & "' is empty. No data to summarize.", False
        GoTo OutputHeadersOnly                   ' Skip aggregation, just output headers
    End If
    sourceDataArr = tblSource.DataBodyRange.Value
    lastRow = UBound(sourceDataArr, 1)

    ' Get column indices from the source table
    sourceColDateIdx = Utils.GetColumnIndexByName(tblSource, Config.DPPM_COL_DATE)
    sourceColOverallQtyIdx = Utils.GetColumnIndexByName(tblSource, Config.DPPM_COL_OVERALL_QTY)
    sourceColOverallRejectIdx = Utils.GetColumnIndexByName(tblSource, Config.DPPM_COL_OVERALL_REJECT)
    sourceColInspectedQtyIdx = Utils.GetColumnIndexByName(tblSource, Config.DPPM_COL_INSPECTED_QTY)
    sourceColInspectedRejectIdx = Utils.GetColumnIndexByName(tblSource, Config.DPPM_COL_INSPECTED_REJECT)
    If sourceColDateIdx = 0 Or sourceColOverallQtyIdx = 0 Or sourceColOverallRejectIdx = 0 Or sourceColInspectedQtyIdx = 0 Or sourceColInspectedRejectIdx = 0 Then GoTo CleanUp ' Error logged in GetColumnIndexByName

    ' Loop through each row in the source sheet
    Dim startTime As Double: startTime = Timer
    Dim formattedDate As String
    For i = 1 To lastRow                         ' Loop through array rows (1-based)
        If i Mod Utils.STATUS_BAR_RECORD_UPDATE_INTERVAL = 0 Or Timer - Utils.g_lngLastStatusBarUpdateTime > Utils.STATUS_BAR_UPDATE_INTERVAL_SECONDS Then
            Utils.UpdateStatusBarProgress "Aggregating " & summaryType, i, lastRow, startTime
        End If
        
        dateValue = sourceDataArr(i, sourceColDateIdx)
        If IsEmpty(dateValue) Or IsNull(dateValue) Or Not IsDate(dateValue) Then
            Utils.LogMessage "[" & procName & "] Skipping row " & i & " due to empty or invalid date value ('" & dateValue & "').", False
            GoTo NextRow  ' Skip this iteration if date is invalid
        End If
        formattedDate = Format(dateValue, "yyyy-mm-dd")
        overallQuantity = SafeToDouble(sourceDataArr(i, sourceColOverallQtyIdx))
        overallRejects = SafeToDouble(sourceDataArr(i, sourceColOverallRejectIdx))
        inspectedQuantity = SafeToDouble(sourceDataArr(i, sourceColInspectedQtyIdx))
        inspectedRejects = SafeToDouble(sourceDataArr(i, sourceColInspectedRejectIdx))

        ' Determine the key based on summary type
        Select Case summaryType
        Case "Daily"
            key = Format(dateValue, "yyyy-mm-dd")
        Case "Weekly"
            'First, validate date
            If Not IsDate(dateValue) Then
                Utils.LogMessage "[" & procName & "] Invalid date value '" & formattedDate & "'. Skipping row " & i, False
                GoTo NextRow
            End If
            
            On Error GoTo WeekNumError
            weekNum = DatePart("ww", dateValue, vbMonday, vbFirstFourDays)
            On Error GoTo 0  ' Reset error handling
            
            ' Defensive range check (allow up to 53 for ISO weeks)
            If weekNum < 1 Or weekNum > 53 Then
                Utils.LogMessage "[" & procName & "] Invalid week number " & weekNum & " for date '" & formattedDate & "'. Skipping row " & i, False
                GoTo NextRow
            End If
            
            ' Build the key
            yearPart = Format(dateValue, "yyyy")
            key = yearPart & "-WW" & Format(weekNum, "00")
            
            GoTo ContinueCode
            
            WeekNumError:
            Utils.LogMessage "[" & procName & "] Failed to get week number for date '" & formattedDate & "'. Skipping row " & i, False
            Resume NextRow
            
            ContinueCode:
        Case "Monthly"
            key = Format(dateValue, "yyyy-mmmm")
        Case Else
            MsgBox "Invalid summary type!", vbExclamation
            Exit Sub
        End Select

        ' Aggregate data
        If Not summaryDict.exists(key) Then
            summaryDict.Add key, Array(0, 0, 0, 0)
        End If
        tempArray = summaryDict(key)
        tempArray(0) = tempArray(0) + overallQuantity
        tempArray(1) = tempArray(1) + overallRejects
        tempArray(2) = tempArray(2) + inspectedQuantity
        tempArray(3) = tempArray(3) + inspectedRejects
        summaryDict(key) = tempArray
NextRow:
    Next i
    Utils.UpdateStatusBarProgress "Aggregating " & summaryType, lastRow, lastRow, startTime ' Final update

OutputHeadersOnly:
    ' Clear target sheet before writing
    wsTarget.Cells.Clear
    Utils.LogMessage "[" & procName & "] Cleared target sheet: '" & targetSheetName & "'."

    ' Write a title for the summary type in A1
    wsTarget.Cells(1, 1).value = summaryType & " DPPM Summary"
    wsTarget.Cells(1, 1).Font.Bold = True

    ' Pre-size the output array for the table (Headers + Data)
    ' Table will start from A2
    ReDim outputArr(1 To summaryDict.Count + 1, 1 To 7) ' +1 for headers

    ' Write headers to the output array (for the table)
    outputArr(1, 1) = Config.SUMMARY_COL_PERIOD  ' e.g., "Date"
    outputArr(1, 2) = Config.SUMMARY_COL_OVERALL_QTY
    outputArr(1, 3) = Config.SUMMARY_COL_OVERALL_REJECT
    outputArr(1, 4) = Config.SUMMARY_COL_OVERALL_DPPM_CALC
    outputArr(1, 5) = Config.SUMMARY_COL_INSPECTED_QTY
    outputArr(1, 6) = Config.SUMMARY_COL_INSPECTED_REJECT
    outputArr(1, 7) = Config.SUMMARY_COL_INSPECTED_DPPM_CALC

    ' Write aggregated data to the output array
    targetRow = 2                                ' Data starts from the second row of outputArr
    For Each key In summaryDict.keys
        tempArray = summaryDict(key)
        overallDPPM = 0
        inspectedDPPM = 0
        If tempArray(0) > 0 Then overallDPPM = (tempArray(1) / tempArray(0)) * 1000000
        If tempArray(2) > 0 Then inspectedDPPM = (tempArray(3) / tempArray(2)) * 1000000

        outputArr(targetRow, 1) = key
        outputArr(targetRow, 2) = tempArray(0)
        outputArr(targetRow, 3) = tempArray(1)
        outputArr(targetRow, 4) = Format(overallDPPM, "0")
        outputArr(targetRow, 5) = tempArray(2)
        outputArr(targetRow, 6) = tempArray(3)
        outputArr(targetRow, 7) = Format(inspectedDPPM, "0")

        targetRow = targetRow + 1
    Next key

    ' Create Excel Table
    Dim dataRange As Range
    Dim tableDataStartCell As Range
    Set tableDataStartCell = wsTarget.Range("A2")

    If summaryDict.Count > 0 Then
        Set dataRange = tableDataStartCell.Resize(summaryDict.Count + 1, 7) ' +1 for headers
        dataRange.value = outputArr
    Else
        ' Only headers if no data
        Set dataRange = tableDataStartCell.Resize(1, 7)
        dataRange.value = Application.WorksheetFunction.Index(outputArr, 1, 0) ' Get first row (headers)
    End If

    ' Remove existing table with the same name
    On Error Resume Next
    wsTarget.ListObjects(targetTableName).Delete
    On Error GoTo ErrorHandler

    Set tblTarget = wsTarget.ListObjects.Add(xlSrcRange, dataRange, , xlYes)
    tblTarget.Name = targetTableName
    tblTarget.TableStyle = Config.DEFAULT_TABLE_STYLE
    Utils.LogMessage "[" & procName & "] Created table '" & targetTableName & "' on sheet '" & targetSheetName & "'."

    ' Sort the table by the date column (first column)
    If tblTarget.ListRows.Count > 0 Then
        With tblTarget.Sort
            .SortFields.Clear
            .SortFields.Add key:=tblTarget.ListColumns(Config.SUMMARY_COL_PERIOD).Range, SortOn:=xlSortOnValues, Order:=xlAscending
            .Header = xlYes
            .MatchCase = False
            .Orientation = xlTopToBottom
            .SortMethod = xlPinYin
            .Apply
        End With
    End If
    Utils.LogMessage "[" & procName & "] Sorted table '" & targetTableName & "'."

    ' Autofit columns and center align
    tblTarget.Range.Columns.AutoFit
    With tblTarget.Range
        .HorizontalAlignment = xlCenter
        .VerticalAlignment = xlCenter
    End With
    Utils.LogMessage "[" & procName & "] " & summaryType & " summary generated successfully on sheet '" & targetSheetName & "', table '" & targetTableName & "'."
    Utils.UpdateStatusBarMessage summaryType & " Summary generated.", stageComplete:=True

CleanUp:
    Set wsSource = Nothing
    Set wsTarget = Nothing
    Set tblSource = Nothing
    Set tblTarget = Nothing
    Exit Sub

ErrorHandler:
    Utils.LogMessage "[" & procName & "] ERROR " & Err.Number & ": " & Err.Description, True
    GoTo CleanUp                                 ' Go to cleanup section
End Sub

Public Sub GenerateSummary()
    Dim procName As String: procName = PROC_GENERATE_SUMMARY
    On Error GoTo ErrorHandler
    Utils.InitStatusBar procName
    Utils.LogMessage "[" & procName & "] Starting summary generation..."
    Application.ScreenUpdating = False
    Application.Calculation = xlCalculationManual
    Application.EnableEvents = False

    ' Load global configuration
    Set m_Config = Utils.GetGlobalConfig()
    If m_Config Is Nothing Or m_Config.Count = 0 Then
        Utils.LogMessage "[" & procName & "] Global configuration not loaded. Aborting.", True
        GoTo CleanUp
    End If
    ' Load configuration for summary sheets/tables
    'If Not LoadAndValidateSummaryConfig() Then GoTo CleanUp ' Error logged inside

    ' Generate summaries
    GenerateSummaryByType "Daily"
    GenerateSummaryByType "Weekly"
    GenerateSummaryByType "Monthly"

    Utils.LogMessage "[" & procName & "] All summaries generated."
    MsgBox "DPPM Summaries generated successfully!", vbInformation

CleanUp:
    If Utils.g_blnStatusBarActive Then Utils.ResetStatusBar procName
    Application.ScreenUpdating = True
    Application.Calculation = xlCalculationAutomatic
    Application.EnableEvents = True
    ' No sheets to protect here usually, but if so, add protection logic
    Exit Sub
ErrorHandler:
    Utils.LogMessage "[" & procName & "] ERROR " & Err.Number & ": " & Err.Description, True
    If Utils.g_blnStatusBarActive Then Utils.ResetStatusBar procName, True, Err.Description
    Resume CleanUp
End Sub

' =====================================================================================
' Private Function: LoadAndValidateSummaryConfig
' Purpose: Loads configuration specific to summary sheets/tables.
' Returns: Boolean (True If valid, False If error)
' =====================================================================================
Private Function LoadAndValidateSummaryConfig() As Boolean
    Dim procName As String: procName = PROC_LOAD_SUMMARY_CONFIG
    Utils.UpdateStatusBarMessage "Loading Summary Configuration...", True
    On Error GoTo ErrorHandler

    If m_Config Is Nothing Or m_Config.Count = 0 Then
        Utils.LogMessage "[" & procName & "] Global configuration (m_Config) is not available.", True
        LoadAndValidateSummaryConfig = False
        Exit Function
    End If

    ' Define required keys for summary output names
    Dim requiredKeys As Variant, keyName As Variant
    ' Use constants from Config.bas for these keys
    requiredKeys = Array( _
                   Config.CONFIG_KEY_DPPM_DAILY_SHEET_NAME, Config.CONFIG_KEY_DPPM_DAILY_TABLE_NAME, _
                   Config.CONFIG_KEY_DPPM_WEEKLY_SHEET_NAME, Config.CONFIG_KEY_DPPM_WEEKLY_TABLE_NAME, _
                   Config.CONFIG_KEY_DPPM_MONTHLY_SHEET_NAME, Config.CONFIG_KEY_DPPM_MONTHLY_TABLE_NAME _
                                                             )

    ' Validate required config keys are present and not empty
    For Each keyName In requiredKeys
        If Not m_Config.exists(keyName) Or Trim(CStr(m_Config(keyName))) = "" Then
            Utils.LogMessage "[" & procName & "] Missing or empty configuration for: '" & keyName & "' in 'Config' sheet.", True
            LoadAndValidateSummaryConfig = False
            Exit Function
        End If
    Next keyName

    ' Assign config values
    m_sDailySummarySheetName = Trim(CStr(m_Config(Config.CONFIG_KEY_DPPM_DAILY_SHEET_NAME)))
    m_sDailySummaryTableName = Trim(CStr(m_Config(Config.CONFIG_KEY_DPPM_DAILY_TABLE_NAME)))
    m_sWeeklySummarySheetName = Trim(CStr(m_Config(Config.CONFIG_KEY_DPPM_WEEKLY_SHEET_NAME)))
    m_sWeeklySummaryTableName = Trim(CStr(m_Config(Config.CONFIG_KEY_DPPM_WEEKLY_TABLE_NAME)))
    m_sMonthlySummarySheetName = Trim(CStr(m_Config(Config.CONFIG_KEY_DPPM_MONTHLY_SHEET_NAME)))
    m_sMonthlySummaryTableName = Trim(CStr(m_Config(Config.CONFIG_KEY_DPPM_MONTHLY_TABLE_NAME)))

    LoadAndValidateSummaryConfig = True
    Utils.LogMessage "[" & procName & "] Summary Configuration loaded and validated successfully."
    Utils.UpdateStatusBarMessage "Summary Configuration loaded.", stageComplete:=True
    Exit Function
ErrorHandler:
    Utils.LogMessage "[" & procName & "] ERROR " & Err.Number & ": " & Err.Description, True
    LoadAndValidateSummaryConfig = False
End Function

' =====================================================================================
' Private Function: GetOrCreateSheet
' Purpose: Returns worksheet by name Or creates it If Not found.
' Uses Utils.GetSheet to check existence.
' =====================================================================================
Private Function GetOrCreateSheet(wb As Workbook, sheetName As String) As Worksheet
    Dim procName As String: procName = "GetOrCreateSheet (Summary)"
    On Error Resume Next                         ' Defer error handling
    Set GetOrCreateSheet = wb.Sheets(sheetName)
    On Error GoTo 0                              ' Restore error handling

    If GetOrCreateSheet Is Nothing Then
        Set GetOrCreateSheet = wb.Sheets.Add
        GetOrCreateSheet.Name = sheetName
        Utils.LogMessage "[" & procName & "] Created new sheet: '" & sheetName & "'."
    Else
        Utils.LogMessage "[" & procName & "] Found existing sheet: '" & sheetName & "'."
    End If
End Function

' =====================================================================================
' Private Function: SafeToDouble
' Purpose: Converts a value to Double, returning 0 if not numeric or error.
' =====================================================================================
Private Function SafeToDouble(val As Variant) As Double
    On Error Resume Next
    SafeToDouble = 0
    If IsNumeric(val) Then SafeToDouble = CDbl(val)
    On Error GoTo 0
End Function


